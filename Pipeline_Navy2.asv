%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                            SHINE LAB, CU BOULDER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is the main analysis script for fNIRS neuroimaging data analysis.
% 2024 - Institute of Cognitive Science, CU-Boulder - James Crum  
% 2025 - Institute of Cognitive Science, CU-Boulder - Jalynn Nicoly

%% Load Folders & Data

% Clears the terminal
clear, clc

% Add NIRS Toolbox to the Matlab path
addpath(genpath('C:\Users\Jalynn\Documents\GitHub\nirs-toolbox'))

% Initialize data directory - equals a string of the path name
Directory = 'C:\Users\Jalynn\Documents\GitHub\Universal_fNIRS_Analyzer\fNIRS';

% Load raw fNIRS intensities
raw = nirs.io.loadDirectory(Directory, {'Subject'});

% Load conditions
conditions = readtable('Conditions.csv');

%% Convert condition codes to string labels (Low & High Germane)

% Converts the conditions table to a cell matrix
conditions = table2cell(conditions);

% For each row in conditions
for i = 1:size(conditions, 1)

    % For only cols 2 and 3
    for j = 2:3

        % Rename 1 to LG and 2 to HG (Low/High Germane)
        if conditions{i,j} == 1
            conditions{i,j} = 'LG';
        elseif conditions{i,j} == 2
            conditions{i,j} = 'HG';
        end
    end
end

%% Load LSL.tri files into a struct (Each ptp has two fields - Timestamps and LSL Trigger Values)

% Find all .tri files in the base directory
triFiles = dir(fullfile(Directory, '**', '*.tri'));

% Initialize a struct to group event data (timestamps and triggers) by participant
eventData_by_ptp = struct();

% For each of the tri files...
for i = 1:numel(triFiles)

    % Extract ptp ID (P001, P002, etc.) by the corresponding file name
    relPath = strrep(triFiles(i).folder, [Directory filesep], ''); % remove base path (directory)
    parts = split(relPath, filesep); % split the remaining path
    ptpFolderName = parts{1}; % first folder = ptp ID
    ptpID = extractBefore(ptpFolderName, ' '); % take the part before first space

    % Load the current .tri file
    triPath = fullfile(triFiles(i).folder, triFiles(i).name);

    % Read the file as a table using the ';' delim
    T = readtable(triPath, 'FileType', 'text', 'Delimiter', ';', 'ReadVariableNames', false);

    % Convert the table to a cell array for easy column extraction
    triData = table2cell(T);

    % Initialize variables for storage
    triTimesSec = [];
    trigValues = [];

    % Need all three columns (PID; timestamp; trigger value)
    if size(triData,2) >= 3

        % Timestamps
        tsColumn_Cell = triData(:, 1); % Extract the first col of timestamps as strings
        tsColumn = string(tsColumn_Cell); % Convert cell array to array
        tsColumn = extractBefore(tsColumn, 24); % Convert microseconds to ms
        triTimestamps = datetime(tsColumn, 'InputFormat', 'yyyy-MM-dd''T''HH:mm:ss.SSS'); % Convert to datetime obj
        triTimesSec = seconds(triTimestamps - triTimestamps(1)); % Calculate relative time in s sinces first event

        % Trigger Values
        trigValues = cell2mat(triData(:, 3));  % Extract the third col of trigger values
    end

    % If the PID already exists...
    if isfield(eventData_by_ptp, ptpID)
        % Throw an error
        error('Participant ID %s already exists in eventData_by_ptp!', ptpID);
    else
        % Else - Store the data in the struct containing both the time vector and trigger codes
        eventData_by_ptp.(ptpID) = struct('Times', {triTimesSec}, 'Triggers', {trigValues}); 
    end
end

%% Insert stimulus designs

% nRaw is equivalent to the number of ptps/subjects
nRaw = length(raw);

% Collect only the ptp ID, not their data
ptpNames = fieldnames(eventData_by_ptp);

% A struct for each ptp with their data
data_trigs = cell(nRaw,1);

for i = 1:min(nRaw,numel(ptpNames))

    % Index the first element - Should look familiar from previous for loop
    data_trigs{i} = eventData_by_ptp.(ptpNames{i});
end

% Initialize a struct for each ptp and their data - Need for raw
AllStims = cell(nRaw,1);

% Initialize an array for the ptps to be excluded - really to throw an error
exclude = [];

% Similar to i - set the index counter
a = 1;

% Loop over each subject saved in raw
for i = 1:nRaw

    % The data of the current ptp
    tempStruct  = data_trigs{i};

    % Check if it is a cell of the data
    if iscell(tempStruct)

         % If it is somehow a cell, set the var as the struct it is holding
         tempStruct = tempStruct{1};
    end

    % Pull the relative time vector that was filled earlier
    triTimesSec = tempStruct(1).Times;

    % Similarly, retrieve the trigger value vector
    trigVec = tempStruct(1).Triggers;

    % Check for sufficient trigger values (must be >= 10)
    if isempty(trigVec) || numel(trigVec) < 10 || isempty(triTimesSec)

        % If not enough trigger values - add that ptp to "exclude"
        exclude(a) = i; a = a+1; continue
    end

    % Check if there are timestamps in the raw data
    if isempty(raw(i).time) || ~isnumeric(raw(i).time)

        % If not - add that ptp to "exclude"
        exclude(a) = i; a = a+1; continue
    end

    %%%%%%% 1) Separate Baseline and Trial Triggers %%%%%%%
    
    % The baseline end markers are triggers 31 and 32
    % reates a vector of 0s and 1s based on 31/32
    is_baseline_marker = (trigVec == 31) | (trigVec == 32); 
    
    % Baseline marker times (end of the 90s baseline period) and values
    % Only draws the timestamps where the vector has 1s - baseline times
    baseline_marker_times = triTimesSec(is_baseline_marker);

    % Similarly, only draws the triggers where the vector has 1s
    baseline_codes = trigVec(is_baseline_marker);
    
    % Experimental trial trigger times and values
    % Is the reverse of is baseline markers
    is_trial = ~is_baseline_marker;

    % Trial times - draws timestamps where the vector has 1s
    trial_onsets_times = triTimesSec(is_trial);

    % Trial trigger values - draws the triggers where vector has 1s
    trial_codes = trigVec(is_trial);

    % Sanity check: Should have 2 baseline markers and 8 trial triggers
    if length(baseline_marker_times) ~= 2 || length(trial_onsets_times) ~= 8

        % Throw a warning if else
        warning('Participant %d: Expected 2 baseline and 8 trial triggers, found %d and %d.', ...
            i, length(baseline_marker_times), length(trial_onsets_times));

        % And add ptp to exclude list
        exclude(a) = i; a = a+1; continue;
    end

    %%%%%%% 2) Extract Trial Onsets and Durations %%%%%%%

    % The experimental trials are paired (odds = start, evens = end)
    % Trial codes only contain trial triggers
    starts = 1:2:length(trial_codes);
    ends = 2:2:length(trial_codes);
    
    % Onsets for the 4 experimental trials 
    trial_onsets = trial_onsets_times(starts);
    trial_end_times = trial_onsets_times(ends); 
    trial_durations = trial_end_times - trial_onsets;
    
    %%%%%%% 3) Define Condition Labels %%%%%%%

    % The 'trial_codes' vector contains 8 trigger values (Start/End for 4 trials)
    % Only the START codes are needed to define the condition for each trial (41/42)
    trial_start_codes = trial_codes(starts);
    
    % Initialize the base names based on the 4 trial start codes ('LG', 'LG', 'HG', 'HG')
    base_names = cell(1, 4);

    % For each start code, determine if the cond is low or high
    for j = 1:4
        code = trial_start_codes(j);
        if code == 41 
            base_names{j} = 'LG';
        elseif code == 42
            base_names{j} = 'HG';
        else

            % Throw an error if an unexpected "start" code is found
            error('Participant %d, Trial %d: Unexpected trial start code found: %d. Expected 41 or 42.', i, j, code);
        end
    end
    
    % Stick to the '41'->'LG' and '42'->'HG' mapping
    lg_cond_name = 'LG';
    hg_cond_name = 'HG';

    % There is a need for 6 total events: 4 trials + 2 baselines
    newStims = cell(6,1); 
    
    %%%%%%% 4) Calculate Baselines (90s BEFORE the marker) and Assign to Conditions %%%%%%%
    
    % Create the Baseline events structure
    baseline_events = struct('names', {}, 'onsets', {}, 'durations', {}, 'amp', {}, 'regressor_no_interest', {});
    
    for k = 1:2
        code = baseline_codes(k); % 31 or 32
        marker_time = baseline_marker_times(k);
        
        % Fixed at 90s
        baseline_duration = 90;
        baseline_onset = marker_time - baseline_duration; 
        
        % Assign names based on baseline code (31/32)
        if code == 31 
            b_name = [lg_cond_name '_Baseline']; % 31 is LG Baseline
        elseif code == 32
            b_name = [hg_cond_name '_Baseline']; % 32 is HG Baseline
        else
            error('Unexpected baseline code: %d', code);
        end
        
        baseline_events(k).names = b_name; 
        baseline_events(k).onsets = baseline_onset;
        baseline_events(k).durations = baseline_duration;
        baseline_events(k).amp = 1;
        baseline_events(k).regressor_no_interest = 0;
    end
    
    %%%%%%% 5) Create Trial Events %%%%%%%

    % Onset and duration of each trial
    trial_events = cell(4, 1);

    for j = 1:4
        % Determine label: 1st and 3rd trial in the sequence are Train, 2nd and 4th are Test.
        % NOTE: If your sequence is always T1-Test, T2-Train, T3-Test, T4-Train, you'll need to change this logic.
        if j==1 || j==3; label='Train'; else; label='Test'; end
        
        % The base_names{j} is now guaranteed to be 'LG' or 'HG' based on the
        % trial's START code (41 or 42) from step 3.
        trial_events{j}.names = [base_names{j} '_' label]; 
        
        trial_events{j}.onsets    = trial_onsets(j);
        trial_events{j}.durations = trial_durations(j);
        trial_events{j}.amp       = 1;
        trial_events{j}.regressor_no_interest = 0;
    end
    
    %%%%%%% 6) Combine and Sort All 6 Events Chronologically %%%%%%%

    % Convert the 1x2 baseline struct array into a 2x1 cell array of structs
    baseline_events_cell = num2cell(baseline_events(:)); 
    % Note: `(:)` forces it into a column vector first, then `num2cell` wraps each struct in a cell.
    
    % Combine the two column cell arrays (2 baseline events + 4 trial events = 6 events)
    combined_events = [baseline_events_cell; trial_events]; % CORRECTED CONCATENATION

    % Extract all onsets from the combined events for sorting
    all_onsets_temp = cellfun(@(x) x.onsets, combined_events);

    % Sort the combined events based on their onset time
    [~, sorted_idx] = sort(all_onsets_temp);
    
    newStims = combined_events(sorted_idx);

    AllStims{i} = newStims;
end

%% ---- Throw error if any exclusions occurred ----

% Remove any duplicates
exclude = unique(exclude);

% Remove any invalid indices (=< 0)
exclude = exclude(exclude > 0);

% If exclude is not empty - Throw an error about problematic ptp(s)
if ~isempty(exclude)
    error(['Participants missing data: ' num2str(exclude)]);
end

%% Working with nirs R

% Loop through each subject's raw data
for i = 1:length(raw)
    
    % Clear our previous stimulus - helps avoid raw numeric triggers
    % Does get replaced later
    raw(i).stimulus = Dictionary;
    
    % Access the cell array of stimulus structs for the current subject
    current_stims = AllStims{i};
    
    % Loop through all 6 stimulus events (2 Baselines + 4 Trials)
    for j = 1:length(current_stims) 
        
        % Create a new stimulus event object for the NIRS Toolbox
        s = nirs.design.StimulusEvents;
        
        % Check if the stimulus data is a struct and not empty
        stim_data = current_stims{j};
        if isstruct(stim_data)
            
            % Populate the stimulus event object 's' with the data
            s.onset = stim_data.onsets;
            s.dur = stim_data.durations;
            
            % Sanity Check (Names were starting with #s previously - not valid for MATLAB)
            temp_name = stim_data.names;
            if isstrprop(char(temp_name(1)), 'digit')
                 s.name = ['Condition_' temp_name];
                 warning('Sanitized numeric name in AllStims for subject %d, originally: %s', i, temp_name);
            else
                 s.name = temp_name; 
            end
            
            % Force amplitude to a vector of ones - Fix issues with jobs.run(Hb)
            if ~isempty(s.onset)
                s.amp = ones(size(s.onset)); 
            else
                s.amp = 1;
            end
            
            % Insert the stimulus obj into the raw data's stimulus dictionary
            raw(i).stimulus(s.name) = s; 
            
            % Clear the temp variable before the next iteration
            clear s
        else
            % Else - Throw warning if stimulus data is not a struct or is empty
            warning('Subject %d, Stimulus %d: Expected struct, but found unexpected type. Skipping.', i, j);
        end
    end
    
    % Sanity Check: Ensure the stimulus field was populated
    if length(raw(i).stimulus.keys) ~= 6

        % Else - Throw a warning
        warning('Subject %d: Expected 6 stimuli, found %d after insertion.', i, length(raw(i).stimulus.keys));
    end
end

% Create a table of the stimulus designs across all subjects for validation
Stim_Table = nirs.createStimulusTable(raw); 

% Display the first few rows of the table to confirm the data looks correct
disp('*** Stimulus Table Head: ***');
disp(head(Stim_Table));

%% Specify short-seperation channels

% Used raw instead of the previously defined r (I did not make a copy of raw)
for i = 1:length(raw)
    probe = raw(i).probe;
    probe.link.ShortSeperation = zeros(height(probe.link),1);
    for j = 1:height(probe.link)
        if probe.link.detector(j) > 28
            probe.link.ShortSeperation(j) = 1;
        end
        raw(i).probe = probe;
    end
end

disp('*** SS Channels flagged on RAW data. ***');

%% Conversions

jobs         = nirs.modules.FixNaNs();
jobs         = nirs.modules.OpticalDensity(jobs);
jobs         = nirs.modules.Resample(jobs);
jobs.Fs      = 1;
jobs         = nirs.modules.BeerLambertLaw(jobs);
Hb = jobs.run(raw);
Hb(1).draw

%% Pre-processing & First-level analysis

jobs = nirs.modules.AddAuxRegressors();
jobs.label = {'aux'};
jobs =nirs.modules.GLM(jobs);
jobs.type = 'AR-IRLS';
jobs.AddShortSepRegressors = true;
jobs = nirs.modules.ExportData(jobs);
jobs.Output ='SubjStats';
jobs.run(Hb)
save('Hb_Final','SubjStats')

%% Second-level analysis

j = nirs.modules.MixedEffects();
j.formula = 'beta ~ -1 + cond + (1|Subject)'; %random effects
j.dummyCoding = 'full';
Group = j.run(SubjStats);

%% Contrasts

% The contrasts are built based on the whiteboard drawing
% Additional cols include the baseline conditions
% HG_Train; HG_Baseline; HG_Test; LG_Train; LG_Baseline; LG_Test
c1 = Group.ttest([1 0 0 0 0 0]);
c2 = Group.ttest([0 0 1 0 0 1]);
c3 = Group.ttest([1 0 0 -1 0 0]);
c4 = Group.ttest([0 0 1 0 0 -1]);
c5 = Group.ttest([1 0 -1 -1 0 -1]);